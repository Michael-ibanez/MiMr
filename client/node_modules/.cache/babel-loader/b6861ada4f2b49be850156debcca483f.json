{"ast":null,"code":"var _slicedToArray = require(\"/Users/michaelibanez/MiMr/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst fs = require('fs');\n\nconst _require = require('path'),\n      extname = _require.extname,\n      basename = _require.basename;\n\nconst Q = require('q');\n\nconst Writable = require(\"stream\").Writable;\n\nconst urlLib = require('url'); // eslint-disable-next-line import/order\n\n\nconst _require2 = require(\"./config\"),\n      upload_prefix = _require2.upload_prefix;\n\nconst isSecure = !(upload_prefix && upload_prefix.slice(0, 5) === 'http:');\nconst https = isSecure ? require('https') : require('http');\n\nconst Cache = require('./cache');\n\nconst utils = require(\"./utils\");\n\nconst UploadStream = require('./upload_stream');\n\nconst build_upload_params = utils.build_upload_params,\n      extend = utils.extend,\n      includes = utils.includes,\n      isObject = utils.isObject,\n      isRemoteUrl = utils.isRemoteUrl,\n      merge = utils.merge;\n\nexports.unsigned_upload_stream = function unsigned_upload_stream(upload_preset, callback, options = {}) {\n  return exports.upload_stream(callback, merge(options, {\n    unsigned: true,\n    upload_preset: upload_preset\n  }));\n};\n\nexports.upload_stream = function upload_stream(callback, options = {}) {\n  return exports.upload(null, callback, extend({\n    stream: true\n  }, options));\n};\n\nexports.unsigned_upload = function unsigned_upload(file, upload_preset, callback, options = {}) {\n  return exports.upload(file, callback, merge(options, {\n    unsigned: true,\n    upload_preset: upload_preset\n  }));\n};\n\nexports.upload = function upload(file, callback, options = {}) {\n  return call_api(\"upload\", callback, options, function () {\n    let params = build_upload_params(options);\n    return isRemoteUrl(file) ? [params, {\n      file: file\n    }] : [params, {}, file];\n  });\n};\n\nexports.upload_large = function upload_large(path, callback, options = {}) {\n  if (path != null && path.match(/^https?:/)) {\n    // upload a remote file\n    return exports.upload(path, callback, options);\n  }\n\n  return exports.upload_chunked(path, callback, {\n    resource_type: 'raw',\n    ...options\n  });\n};\n\nexports.upload_chunked = function upload_chunked(path, callback, options) {\n  let file_reader = fs.createReadStream(path);\n  let out_stream = exports.upload_chunked_stream(callback, options);\n  return file_reader.pipe(out_stream);\n};\n\nclass Chunkable extends Writable {\n  constructor(options) {\n    super(options);\n    this.chunk_size = options.chunk_size != null ? options.chunk_size : 20000000;\n    this.buffer = Buffer.alloc(0);\n    this.active = true;\n    this.on('finish', () => {\n      if (this.active) {\n        this.emit('ready', this.buffer, true, function () {});\n      }\n    });\n  }\n\n  _write(data, encoding, done) {\n    if (!this.active) {\n      done();\n    }\n\n    if (this.buffer.length + data.length <= this.chunk_size) {\n      this.buffer = Buffer.concat([this.buffer, data], this.buffer.length + data.length);\n      done();\n    } else {\n      const grab = this.chunk_size - this.buffer.length;\n      this.buffer = Buffer.concat([this.buffer, data.slice(0, grab)], this.buffer.length + grab);\n      this.emit('ready', this.buffer, false, active => {\n        this.active = active;\n\n        if (this.active) {\n          this.buffer = data.slice(grab);\n          done();\n        }\n      });\n    }\n  }\n\n}\n\nexports.upload_large_stream = function upload_large_stream(_unused_, callback, options = {}) {\n  return exports.upload_chunked_stream(callback, extend({\n    resource_type: 'raw'\n  }, options));\n};\n\nexports.upload_chunked_stream = function upload_chunked_stream(callback, options = {}) {\n  options = extend({}, options, {\n    stream: true\n  });\n  options.x_unique_upload_id = utils.random_public_id();\n  let params = build_upload_params(options);\n  let chunk_size = options.chunk_size != null ? options.chunk_size : options.part_size;\n  let chunker = new Chunkable({\n    chunk_size: chunk_size\n  });\n  let sent = 0;\n  chunker.on('ready', function (buffer, is_last, done) {\n    let chunk_start = sent;\n    sent += buffer.length;\n    options.content_range = \"bytes \".concat(chunk_start, \"-\").concat(sent - 1, \"/\").concat(is_last ? sent : -1);\n    params.timestamp = utils.timestamp();\n\n    let finished_part = function (result) {\n      const errorOrLast = result.error != null || is_last;\n\n      if (errorOrLast && typeof callback === \"function\") {\n        callback(result);\n      }\n\n      return done(!errorOrLast);\n    };\n\n    let stream = call_api(\"upload\", finished_part, options, function () {\n      return [params, {}, buffer];\n    });\n    return stream.write(buffer, 'buffer', function () {\n      return stream.end();\n    });\n  });\n  return chunker;\n};\n\nexports.explicit = function explicit(public_id, callback, options = {}) {\n  return call_api(\"explicit\", callback, options, function () {\n    return utils.build_explicit_api_params(public_id, options);\n  });\n}; // Creates a new archive in the server and returns information in JSON format\n\n\nexports.create_archive = function create_archive(callback, options = {}, target_format = null) {\n  return call_api(\"generate_archive\", callback, options, function () {\n    let opt = utils.archive_params(options);\n\n    if (target_format) {\n      opt.target_format = target_format;\n    }\n\n    return [opt];\n  });\n}; // Creates a new zip archive in the server and returns information in JSON format\n\n\nexports.create_zip = function create_zip(callback, options = {}) {\n  return exports.create_archive(callback, options, \"zip\");\n};\n\nexports.destroy = function destroy(public_id, callback, options = {}) {\n  return call_api(\"destroy\", callback, options, function () {\n    return [{\n      timestamp: utils.timestamp(),\n      type: options.type,\n      invalidate: options.invalidate,\n      public_id: public_id\n    }];\n  });\n};\n\nexports.rename = function rename(from_public_id, to_public_id, callback, options = {}) {\n  return call_api(\"rename\", callback, options, function () {\n    return [{\n      timestamp: utils.timestamp(),\n      type: options.type,\n      from_public_id: from_public_id,\n      to_public_id: to_public_id,\n      overwrite: options.overwrite,\n      invalidate: options.invalidate,\n      to_type: options.to_type\n    }];\n  });\n};\n\nconst TEXT_PARAMS = [\"public_id\", \"font_family\", \"font_size\", \"font_color\", \"text_align\", \"font_weight\", \"font_style\", \"background\", \"opacity\", \"text_decoration\", \"font_hinting\", \"font_antialiasing\"];\n\nexports.text = function text(content, callback, options = {}) {\n  return call_api(\"text\", callback, options, function () {\n    let textParams = utils.only(options, ...TEXT_PARAMS);\n    let params = {\n      timestamp: utils.timestamp(),\n      text: content,\n      ...textParams\n    };\n    return [params];\n  });\n};\n\nexports.generate_sprite = function generate_sprite(tag, callback, options = {}) {\n  return call_api(\"sprite\", callback, options, function () {\n    const transformation = utils.generate_transformation_string(extend({}, options, {\n      fetch_format: options.format\n    }));\n    return [{\n      timestamp: utils.timestamp(),\n      tag: tag,\n      transformation: transformation,\n      async: options.async,\n      notification_url: options.notification_url\n    }];\n  });\n};\n\nexports.multi = function multi(tag, callback, options = {}) {\n  return call_api(\"multi\", callback, options, function () {\n    const transformation = utils.generate_transformation_string(extend({}, options));\n    return [{\n      timestamp: utils.timestamp(),\n      tag: tag,\n      transformation: transformation,\n      format: options.format,\n      async: options.async,\n      notification_url: options.notification_url\n    }];\n  });\n};\n\nexports.explode = function explode(public_id, callback, options = {}) {\n  return call_api(\"explode\", callback, options, function () {\n    const transformation = utils.generate_transformation_string(extend({}, options));\n    return [{\n      timestamp: utils.timestamp(),\n      public_id: public_id,\n      transformation: transformation,\n      format: options.format,\n      type: options.type,\n      notification_url: options.notification_url\n    }];\n  });\n}; // options may include 'exclusive' (boolean) which causes clearing this tag from all other resources\n\n\nexports.add_tag = function add_tag(tag, public_ids = [], callback, options = {}) {\n  const exclusive = utils.option_consume(\"exclusive\", options);\n  const command = exclusive ? \"set_exclusive\" : \"add\";\n  return call_tags_api(tag, command, public_ids, callback, options);\n};\n\nexports.remove_tag = function remove_tag(tag, public_ids = [], callback, options = {}) {\n  return call_tags_api(tag, \"remove\", public_ids, callback, options);\n};\n\nexports.remove_all_tags = function remove_all_tags(public_ids = [], callback, options = {}) {\n  return call_tags_api(null, \"remove_all\", public_ids, callback, options);\n};\n\nexports.replace_tag = function replace_tag(tag, public_ids = [], callback, options = {}) {\n  return call_tags_api(tag, \"replace\", public_ids, callback, options);\n};\n\nfunction call_tags_api(tag, command, public_ids = [], callback, options = {}) {\n  return call_api(\"tags\", callback, options, function () {\n    let params = {\n      timestamp: utils.timestamp(),\n      public_ids: utils.build_array(public_ids),\n      command: command,\n      type: options.type\n    };\n\n    if (tag != null) {\n      params.tag = tag;\n    }\n\n    return [params];\n  });\n}\n\nexports.add_context = function add_context(context, public_ids = [], callback, options = {}) {\n  return call_context_api(context, 'add', public_ids, callback, options);\n};\n\nexports.remove_all_context = function remove_all_context(public_ids = [], callback, options = {}) {\n  return call_context_api(null, 'remove_all', public_ids, callback, options);\n};\n\nfunction call_context_api(context, command, public_ids = [], callback, options = {}) {\n  return call_api('context', callback, options, function () {\n    let params = {\n      timestamp: utils.timestamp(),\n      public_ids: utils.build_array(public_ids),\n      command: command,\n      type: options.type\n    };\n\n    if (context != null) {\n      params.context = utils.encode_context(context);\n    }\n\n    return [params];\n  });\n}\n/**\n * Cache (part of) the upload results.\n * @param result\n * @param {object} options\n * @param {string} options.type\n * @param {string} options.resource_type\n */\n\n\nfunction cacheResults(result, {\n  type,\n  resource_type\n}) {\n  if (result.responsive_breakpoints) {\n    result.responsive_breakpoints.forEach(({\n      transformation,\n      url,\n      breakpoints\n    }) => Cache.set(result.public_id, {\n      type,\n      resource_type,\n      raw_transformation: transformation,\n      format: extname(breakpoints[0].url).slice(1)\n    }, breakpoints.map(i => i.width)));\n  }\n}\n\nfunction parseResult(buffer, res) {\n  let result = '';\n\n  try {\n    result = JSON.parse(buffer);\n  } catch (jsonError) {\n    result = {\n      error: {\n        message: \"Server return invalid JSON response. Status Code \".concat(res.statusCode, \". \").concat(jsonError)\n      }\n    };\n  }\n\n  return result;\n}\n\nfunction call_api(action, callback, options, get_params) {\n  if (typeof callback !== \"function\") {\n    callback = function () {};\n  }\n\n  let deferred = Q.defer();\n\n  if (options == null) {\n    options = {};\n  }\n\n  let _get_params$call = get_params.call(),\n      _get_params$call2 = _slicedToArray(_get_params$call, 3),\n      params = _get_params$call2[0],\n      unsigned_params = _get_params$call2[1],\n      file = _get_params$call2[2];\n\n  params = utils.process_request_params(params, options);\n  params = extend(params, unsigned_params);\n  let api_url = utils.api_url(action, options);\n  let boundary = utils.random_public_id();\n  let errorRaised = false;\n\n  let handle_response = function (res) {\n    // var buffer;\n    if (errorRaised) {// Already reported\n    } else if (res.error) {\n      errorRaised = true;\n      deferred.reject(res);\n      callback(res);\n    } else if (includes([200, 400, 401, 404, 420, 500], res.statusCode)) {\n      let buffer = \"\";\n      res.on(\"data\", d => {\n        buffer += d;\n        return buffer;\n      });\n      res.on(\"end\", () => {\n        let result;\n\n        if (errorRaised) {\n          return;\n        }\n\n        result = parseResult(buffer, res);\n\n        if (result.error) {\n          result.error.http_code = res.statusCode;\n          deferred.reject(result.error);\n        } else {\n          cacheResults(result, options);\n          deferred.resolve(result);\n        }\n\n        callback(result);\n      });\n      res.on(\"error\", error => {\n        errorRaised = true;\n        deferred.reject(error);\n        callback({\n          error\n        });\n      });\n    } else {\n      let error = {\n        message: \"Server returned unexpected status code - \".concat(res.statusCode),\n        http_code: res.statusCode\n      };\n      deferred.reject(error);\n      callback({\n        error\n      });\n    }\n  };\n\n  let post_data = utils.hashToParameters(params).filter(([key, value]) => value != null).map(([key, value]) => Buffer.from(encodeFieldPart(boundary, key, value), 'utf8'));\n  let result = post(api_url, post_data, boundary, file, handle_response, options);\n\n  if (isObject(result)) {\n    return result;\n  }\n\n  return deferred.promise;\n}\n\nfunction post(url, post_data, boundary, file, callback, options) {\n  var file_header;\n  let finish_buffer = Buffer.from(\"--\" + boundary + \"--\", 'ascii');\n\n  if (file != null || options.stream) {\n    let filename = options.stream ? \"file\" : basename(file);\n    file_header = Buffer.from(encodeFilePart(boundary, 'application/octet-stream', 'file', filename), 'binary');\n  }\n\n  let post_options = urlLib.parse(url);\n  let headers = {\n    'Content-Type': \"multipart/form-data; boundary=\".concat(boundary),\n    'User-Agent': utils.getUserAgent()\n  };\n\n  if (options.content_range != null) {\n    headers['Content-Range'] = options.content_range;\n  }\n\n  if (options.x_unique_upload_id != null) {\n    headers['X-Unique-Upload-Id'] = options.x_unique_upload_id;\n  }\n\n  post_options = extend(post_options, {\n    method: 'POST',\n    headers: headers\n  });\n\n  if (options.agent != null) {\n    post_options.agent = options.agent;\n  }\n\n  let post_request = https.request(post_options, callback);\n  let upload_stream = new UploadStream({\n    boundary\n  });\n  upload_stream.pipe(post_request);\n  let timeout = false;\n  post_request.on(\"error\", function (error) {\n    if (timeout) {\n      error = {\n        message: \"Request Timeout\",\n        http_code: 499\n      };\n    }\n\n    return callback({\n      error\n    });\n  });\n  post_request.setTimeout(options.timeout != null ? options.timeout : 60000, function () {\n    timeout = true;\n    return post_request.abort();\n  });\n  post_data.forEach(postDatum => post_request.write(postDatum));\n\n  if (options.stream) {\n    post_request.write(file_header);\n    return upload_stream;\n  }\n\n  if (file != null) {\n    post_request.write(file_header);\n    fs.createReadStream(file).on('error', function (error) {\n      callback({\n        error: error\n      });\n      return post_request.abort();\n    }).pipe(upload_stream);\n  } else {\n    post_request.write(finish_buffer);\n    post_request.end();\n  }\n\n  return true;\n}\n\nfunction encodeFieldPart(boundary, name, value) {\n  return [\"--\".concat(boundary), \"Content-Disposition: form-data; name=\\\"\".concat(name, \"\\\"\"), '', value, ''].join(\"\\r\\n\");\n}\n\nfunction encodeFilePart(boundary, type, name, filename) {\n  return [\"--\".concat(boundary), \"Content-Disposition: form-data; name=\\\"\".concat(name, \"\\\"; filename=\\\"\").concat(filename, \"\\\"\"), \"Content-Type: \".concat(type), '', ''].join(\"\\r\\n\");\n}\n\nexports.direct_upload = function direct_upload(callback_url, options = {}) {\n  let params = build_upload_params(extend({\n    callback: callback_url\n  }, options));\n  params = utils.process_request_params(params, options);\n  let api_url = utils.api_url(\"upload\", options);\n  return {\n    hidden_fields: params,\n    form_attrs: {\n      action: api_url,\n      method: \"POST\",\n      enctype: \"multipart/form-data\"\n    }\n  };\n};\n\nexports.upload_tag_params = function upload_tag_params(options = {}) {\n  let params = build_upload_params(options);\n  params = utils.process_request_params(params, options);\n  return JSON.stringify(params);\n};\n\nexports.upload_url = function upload_url(options = {}) {\n  if (options.resource_type == null) {\n    options.resource_type = \"auto\";\n  }\n\n  return utils.api_url(\"upload\", options);\n};\n\nexports.image_upload_tag = function image_upload_tag(field, options = {}) {\n  let html_options = options.html || {};\n  let tag_options = extend({\n    type: \"file\",\n    name: \"file\",\n    \"data-url\": exports.upload_url(options),\n    \"data-form-data\": exports.upload_tag_params(options),\n    \"data-cloudinary-field\": field,\n    \"data-max-chunk-size\": options.chunk_size,\n    \"class\": [html_options.class, \"cloudinary-fileupload\"].join(\" \")\n  }, html_options);\n  return \"<input \".concat(utils.html_attrs(tag_options), \"/>\");\n};\n\nexports.unsigned_image_upload_tag = function unsigned_image_upload_tag(field, upload_preset, options = {}) {\n  return exports.image_upload_tag(field, merge(options, {\n    unsigned: true,\n    upload_preset: upload_preset\n  }));\n};","map":null,"metadata":{},"sourceType":"script"}