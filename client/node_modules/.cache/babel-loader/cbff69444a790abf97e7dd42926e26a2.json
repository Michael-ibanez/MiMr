{"ast":null,"code":"const _ = require('lodash');\n\nexports.config = require(\"./config\");\nexports.utils = require(\"./utils\");\nexports.uploader = require(\"./uploader\");\nexports.api = require(\"./api\");\nexports.PreloadedFile = require(\"./preloaded_file\");\nexports.Cache = require('./cache');\nconst cloudinary = module.exports;\nconst optionConsume = cloudinary.utils.option_consume;\n\nexports.url = function url(public_id, options) {\n  options = _.extend({}, options);\n  return cloudinary.utils.url(public_id, options);\n};\n\nconst _require = require('./utils/srcsetUtils'),\n      generateImageResponsiveAttributes = _require.generateImageResponsiveAttributes,\n      generateMediaAttr = _require.generateMediaAttr;\n/**\n * Helper function, allows chaining transformation to the end of transformation list\n *\n * @private\n * @param {object} options Original options\n * @param {object|object[]} transformation Transformations to chain at the end\n *\n * @return {object} Resulting options\n */\n\n\nfunction chainTransformations(options, transformation = []) {\n  // preserve url options\n  let urlOptions = cloudinary.utils.extractUrlParams(options);\n  let currentTransformation = cloudinary.utils.extractTransformationParams(options);\n  transformation = cloudinary.utils.build_array(transformation);\n  urlOptions.transformation = [currentTransformation, ...transformation];\n  return urlOptions;\n}\n/**\n * Generate an HTML img tag with a Cloudinary URL\n * @param {string} source A Public ID or a URL\n * @param {object} options Configuration options\n * @param {srcset} options.srcset srcset options\n * @param {object} options.attributes HTML attributes\n * @param {number} options.html_width (deprecated) The HTML tag width\n * @param {number} options.html_height (deprecated) The HTML tag height\n * @param {boolean} options.client_hints Don't implement the client side responsive function.\n *                  This argument can override the the same option in the global configuration.\n * @param {boolean} options.responsive Setup the tag for the client side responsive function.\n * @param {boolean} options.hidpi Setup the tag for the client side auto dpr function.\n * @param {boolean} options.responsive_placeholder A place holder image URL to use with.\n *                  the client side responsive function\n * @return {string} An HTML img tag\n */\n\n\nexports.image = function image(source, options) {\n  let localOptions = _.extend({}, options);\n\n  let srcsetParam = optionConsume(localOptions, 'srcset');\n  let attributes = optionConsume(localOptions, 'attributes', {});\n  let src = cloudinary.utils.url(source, localOptions);\n  if (\"html_width\" in localOptions) localOptions.width = optionConsume(localOptions, \"html_width\");\n  if (\"html_height\" in localOptions) localOptions.height = optionConsume(localOptions, \"html_height\");\n  let client_hints = optionConsume(localOptions, \"client_hints\", cloudinary.config().client_hints);\n  let responsive = optionConsume(localOptions, \"responsive\");\n  let hidpi = optionConsume(localOptions, \"hidpi\");\n\n  if ((responsive || hidpi) && !client_hints) {\n    localOptions[\"data-src\"] = src;\n    let classes = [responsive ? \"cld-responsive\" : \"cld-hidpi\"];\n    let current_class = optionConsume(localOptions, \"class\");\n    if (current_class) classes.push(current_class);\n    localOptions.class = classes.join(\" \");\n    src = optionConsume(localOptions, \"responsive_placeholder\", cloudinary.config().responsive_placeholder);\n\n    if (src === \"blank\") {\n      src = cloudinary.BLANK;\n    }\n  }\n\n  let html = \"<img \";\n  if (src) html += \"src='\" + src + \"' \";\n  let responsiveAttributes = {};\n\n  if (cloudinary.utils.isString(srcsetParam)) {\n    responsiveAttributes.srcset = srcsetParam;\n  } else {\n    responsiveAttributes = generateImageResponsiveAttributes(source, attributes, srcsetParam, options);\n  }\n\n  if (!cloudinary.utils.isEmpty(responsiveAttributes)) {\n    delete localOptions.width;\n    delete localOptions.height;\n  }\n\n  html += cloudinary.utils.html_attrs(_.extend(localOptions, responsiveAttributes, attributes)) + \"/>\";\n  return html;\n};\n/**\n * Creates an HTML video tag for the provided public_id\n * @param {String} public_id the resource public ID\n * @param {Object} [options] options for the resource and HTML tag\n * @param {(String|Array<String>)} [options.source_types] Specify which\n *        source type the tag should include. defaults to webm, mp4 and ogv.\n * @param {String} [options.source_transformation] specific transformations\n *        to use for a specific source type.\n * @param {(String|Object)} [options.poster] image URL or\n *        poster options that may include a <tt>public_id</tt> key and\n *        poster-specific transformations\n * @example <caption>Example of generating a video tag:</caption>\n * cloudinary.video(\"mymovie.mp4\");\n * cloudinary.video(\"mymovie.mp4\", {source_types: 'webm'});\n * cloudinary.video(\"mymovie.ogv\", {poster: \"myspecialplaceholder.jpg\"});\n * cloudinary.video(\"mymovie.webm\", {source_types: ['webm', 'mp4'], poster: {effect: 'sepia'}});\n * @return {string} HTML video tag\n */\n\n\nexports.video = function video(public_id, options) {\n  options = _.extend({}, options);\n  public_id = public_id.replace(/\\.(mp4|ogv|webm)$/, '');\n  let source_types = optionConsume(options, 'source_types', []);\n  let source_transformation = optionConsume(options, 'source_transformation', {});\n  let fallback = optionConsume(options, 'fallback_content', '');\n  if (source_types.length === 0) source_types = cloudinary.utils.DEFAULT_VIDEO_SOURCE_TYPES;\n\n  let video_options = _.cloneDeep(options);\n\n  if (video_options.hasOwnProperty('poster')) {\n    if (_.isPlainObject(video_options.poster)) {\n      if (video_options.poster.hasOwnProperty('public_id')) {\n        video_options.poster = cloudinary.utils.url(video_options.poster.public_id, video_options.poster);\n      } else {\n        video_options.poster = cloudinary.utils.url(public_id, _.extend({}, cloudinary.utils.DEFAULT_POSTER_OPTIONS, video_options.poster));\n      }\n    }\n  } else {\n    video_options.poster = cloudinary.utils.url(public_id, _.extend({}, cloudinary.utils.DEFAULT_POSTER_OPTIONS, options));\n  }\n\n  if (!video_options.poster) delete video_options.poster;\n  let html = '<video ';\n  if (!video_options.hasOwnProperty('resource_type')) video_options.resource_type = 'video';\n  let multi_source = _.isArray(source_types) && source_types.length > 1;\n  let source = public_id;\n\n  if (!multi_source) {\n    source = source + '.' + cloudinary.utils.build_array(source_types)[0];\n  }\n\n  let src = cloudinary.utils.url(source, video_options); // calculate src and reduce video_options\n\n  if (!multi_source) {\n    video_options.src = src;\n  }\n\n  if (video_options.hasOwnProperty(\"html_width\")) video_options.width = optionConsume(video_options, 'html_width');\n  if (video_options.hasOwnProperty(\"html_height\")) video_options.height = optionConsume(video_options, 'html_height');\n  html = html + cloudinary.utils.html_attrs(video_options) + '>';\n\n  if (multi_source) {\n    html += source_types.map(source_type => {\n      let transformation = source_transformation[source_type] || {};\n      let sourceSrc = cloudinary.utils.url(source + \".\" + source_type, _.extend({\n        resource_type: 'video'\n      }, _.cloneDeep(options), _.cloneDeep(transformation)));\n      let video_type = source_type === 'ogv' ? 'ogg' : source_type;\n      let type = \"video/\" + video_type;\n      return \"<source \".concat(cloudinary.utils.html_attrs({\n        src: sourceSrc,\n        type\n      }), \">\");\n    }).join('');\n  }\n\n  html = html + fallback;\n  html = html + '</video>';\n  return html;\n};\n/**\n * Generate a <code>source</code> tag.\n * @param {string} public_id\n * @param {object} options\n * @param {srcset} options.srcset arguments required to generate the srcset attribute.\n * @param {object} options.attributes HTML tag attributes\n * @return {string}\n */\n\n\nexports.source = function source(public_id, options = {}) {\n  let srcsetParam = cloudinary.utils.extend({}, options.srcset, cloudinary.config().srcset);\n  let attributes = options.attributes || {};\n  cloudinary.utils.extend(attributes, generateImageResponsiveAttributes(public_id, attributes, srcsetParam, options));\n\n  if (!attributes.srcset) {\n    attributes.srcset = cloudinary.url(public_id, options);\n  }\n\n  if (!attributes.media && options.media) {\n    attributes.media = generateMediaAttr(options.media);\n  }\n\n  return \"<source \".concat(cloudinary.utils.html_attrs(attributes), \">\");\n};\n/**\n * Generate a <code>picture</code> HTML tag.<br>\n *   The sources argument defines different transformations to apply for each\n *   media query.\n * @param {string}public_id\n * @param {object} options\n * @param {object[]} options.sources a list of source arguments. A source tag will be rendered for each item\n * @param {number} options.sources.min_width a minimum width query\n * @param {number} options.sources.max_width a maximum width query\n * @param {number} options.sources.transformation the transformation to apply to the source tag.\n * @return {string} A picture HTML tag\n * @example\n *\n * cloudinary.picture(\"sample\", {\n *   sources: [\n *     {min_width: 1600, transformation: {crop: 'fill', width: 800, aspect_ratio: 2}},\n *     {min_width: 500, transformation: {crop: 'fill', width: 600, aspect_ratio: 2.3}},\n *     {transformation: {crop: 'crop', width: 400, gravity: 'auto'}},\n *     ]}\n * );\n */\n\n\nexports.picture = function picture(public_id, options = {}) {\n  let sources = options.sources || [];\n  options = cloudinary.utils.clone(options);\n  delete options.sources;\n  cloudinary.utils.patchFetchFormat(options);\n  return \"<picture>\" + sources.map(source => {\n    let sourceOptions = chainTransformations(options, source.transformation);\n    sourceOptions.media = source;\n    return cloudinary.source(public_id, sourceOptions);\n  }).join('') + cloudinary.image(public_id, options) + \"</picture>\";\n};\n\nexports.cloudinary_js_config = cloudinary.utils.cloudinary_js_config;\nexports.CF_SHARED_CDN = cloudinary.utils.CF_SHARED_CDN;\nexports.AKAMAI_SHARED_CDN = cloudinary.utils.AKAMAI_SHARED_CDN;\nexports.SHARED_CDN = cloudinary.utils.SHARED_CDN;\nexports.BLANK = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\nexports.v2 = require('./v2');","map":null,"metadata":{},"sourceType":"script"}