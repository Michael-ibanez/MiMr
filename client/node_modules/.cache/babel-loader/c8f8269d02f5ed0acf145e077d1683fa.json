{"ast":null,"code":"var PRELOADED_CLOUDINARY_PATH, config, utils;\nutils = require(\"./utils\");\nconfig = require(\"./config\");\nPRELOADED_CLOUDINARY_PATH = /^([^\\/]+)\\/([^\\/]+)\\/v(\\d+)\\/([^#]+)#([^\\/]+)$/;\n\nclass PreloadedFile {\n  constructor(file_info) {\n    var matches, public_id_and_format;\n    matches = file_info.match(PRELOADED_CLOUDINARY_PATH);\n\n    if (!matches) {\n      throw \"Invalid preloaded file info\";\n    }\n\n    this.resource_type = matches[1];\n    this.type = matches[2];\n    this.version = matches[3];\n    this.filename = matches[4];\n    this.signature = matches[5];\n    public_id_and_format = PreloadedFile.split_format(this.filename);\n    this.public_id = public_id_and_format[0];\n    this.format = public_id_and_format[1];\n  }\n\n  is_valid() {\n    var expected_signature;\n    expected_signature = utils.api_sign_request({\n      public_id: this.public_id,\n      version: this.version\n    }, config().api_secret);\n    return this.signature === expected_signature;\n  }\n\n  static split_format(identifier) {\n    var format, last_dot, public_id;\n    last_dot = identifier.lastIndexOf(\".\");\n\n    if (last_dot === -1) {\n      return [identifier, null];\n    }\n\n    public_id = identifier.substr(0, last_dot);\n    format = identifier.substr(last_dot + 1);\n    return [public_id, format];\n  }\n\n  identifier() {\n    return \"v\".concat(this.version, \"/\").concat(this.filename);\n  }\n\n  toString() {\n    return \"\".concat(this.resource_type, \"/\").concat(this.type, \"/v\").concat(this.version, \"/\").concat(this.filename, \"#\").concat(this.signature);\n  }\n\n  toJSON() {\n    var result = {};\n    Object.getOwnPropertyNames(this).forEach(key => {\n      let val = this[key];\n\n      if (typeof val !== 'function') {\n        result[key] = val;\n      }\n    });\n    return result;\n  }\n\n}\n\nmodule.exports = PreloadedFile;","map":null,"metadata":{},"sourceType":"script"}